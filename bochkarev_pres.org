#+TITLE:  Selected Topics in Network Optimization:
#+TITLE: Aligning BDDs for a Facility Location Problem
#+TITLE: and a Search Tree Method for DSPI.
#+SUBTITLE: Dissertation defense
#+AUTHOR: Alexey Bochkarev
#+EMAIL: abochka@g.clemson.edu
#+DATE: 2021-11-02 Tue, 08-30, Zoom / Freeman Hall 129

#+startup: beamer
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [10pt, xcolor=svgnames]
#+BEAMER_THEME: Darmstadt
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{calc}
#+LATEX_HEADER: \usetikzlibrary{tikzmark}
#+LATEX_HEADER: \usepackage[beamer]{hf-tikz}
#+LATEX_HEADER: \usetikzlibrary{arrows} % For nice arrow tips (Align-BDD)
#+LATEX_HEADER: \setbeamertemplate{blocks}[rounded][shadow=false]
#+LATEX_HEADER: \usepackage{bibentry}
#+LATEX_HEADER: \nobibliography*
#+LATEX_HEADER: \input{notation_def.tex}
#+LATEX_HEADER: \beamertemplatenavigationsymbolsempty
#+OPTIONS: H:3  tags:not-in-toc toc:nil
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+CATEGORY: Draft


 #+begin_export latex
 {%<--- Start local changes
 \setbeamertemplate{navigation symbols}{}
 \usebackgroundtemplate{\includegraphics[width=\paperwidth]{./img/coffee.JPG}}
 \begin{frame}[plain,b]
 \centering
 \LARGE Thanks for joining in the morning!\vspace{4ex}
 \end{frame}
 }%<---- Finish local changes
 #+end_export

*** Presentation outline
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
 #+LATEX: \tableofcontents

* TODO Aligning BDDs
  :LOGBOOK:
  CLOCK: [2021-10-30 Sat 21:11]--[2021-10-30 Sat 23:10] =>  1:59
  CLOCK: [2021-10-30 Sat 20:45]--[2021-10-30 Sat 20:45] =>  0:00
  :END:
** On BDD representations
*** What is an (O)BDD?                                              :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
**** Left                                                    :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.40
     :BEAMER_opt: t
     :END:
     \textbf{In a nutshell:}
     - A (maybe weighted) layered (D)AG
     - Two outgoing arcs from each node
     - One root, two terminals\vspace{2ex}

       \includegraphics[width=0.6\textwidth]{./img/simple-BDD.png}
**** Right                                                   :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.5
     :BEAMER_opt: t
     :END:
     \textbf{Applications:}
     - Can encode a Boolean function ...
     - ... or a combinatorial opt problem.
       
     \textbf{How it works:}
     - A layer corresponds to a ``decision'' (binary variable),
     - *one-arc* (or yes-arc) -- $x_i=1$,
     - *zero-arc* (or no-arc) -- $x_i=0$.
     - A *path* from root to terminal corresponds to an assignment of all
       variables.
*** Order of variables matters: a MIS example                       :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
**** Original graph                                          :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.2
     :END:
     \centering
     \textbf{Original graph:}\vspace{2ex}
     \includegraphics[height=0.6\textheight]{./img/BDDsampleGraph.png}
**** 14-nodes                                                :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.35
     :END:
     \centering
     \textbf{14 nodes:}\vspace{2ex}
     \includegraphics[height=0.7\textheight]{./img/BDDsampleRep1.png}
**** 17-nodes                                                :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.55
     :END:
     \centering
     \textbf{17 nodes:}\vspace{2ex}
     \includegraphics[height=0.7\textheight]{./img/BDDsampleRep2.png}
*** The *same* order of variables also matters                      :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
    - Many problems can be reformulated as a set of (connected) instances
      over a collection of BDDs.
    - If we have the same order of variables: cite:lozano2020 proposed an algorithm
      how to tackle such instances.
    - So, finding a good shared order of variables might be desirable.
*** A motivating example: t-UFLP                                    :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
**** Fig                                                     :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.2
     :END:
     \includegraphics[height=0.8\textheight]{./img/tUFLP.png}
**** Description                                             :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.8
     :END:
     \textbf{Assume:}
     - A graph; can *locate* a facility at any point,
     - A located facility *covers* all neighboring points.

     \textbf{Objective:} cover all points at min cost.

     \textbf{Constraints:}
     - Each point implies a facility *``type''*,
     - There is a limit on number of facilities by type.
*** How to merge two diagrams?                                      :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
    \centering
    \includegraphics[width=\textwidth]{./img/merging.png}

    Source: cite:lozano2020
*** A motivating example: t-UFLP                                    :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
**** Fig                                                     :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.2
     :END:
     \includegraphics[height=0.8\textheight]{./img/tUFLP.png}
**** Description                                             :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.8
     :END:
     \textbf{Plan of attack:}
     - Formulate the problem with two BDDs,
     - @@latex:\tikzmarkin<2->{this}Enforce the shared order of variables\tikzmarkend{this}, \onslide<2->{\alert{$\leftarrow$ this part}}@@
     - Merge (``intersect'') the two diagrams into one*
     - Solve a shortest-path in the intersection DD.
*** In this section:
    - BDD alignment problem,
    - A simplified model / heuristic,
    - Numerical experiments on aligning BDDs.
** BDD alignment (``original'') problem
*** BDD alignment problem
Let us denote $T^*[D,\vec{v}]$ -- a ``transformed'' version of BDD $D$ to variable order $\vec{v}=(v_1,\ldots,v_N)$. Then:
**** BDD Alignment Problem / ``original'' problem                   :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     #+begin_export latex
\begin{align*}
     s^* = \min_{\vec{v}} \Big\{ |T^*[A, \vec{v}]| + |T^*[B, \vec{v}]| \Big\},
\end{align*}
     #+end_export
**** Notes                                                  :B_ignoreheading:
     :PROPERTIES:
     :BEAMER_env: ignoreheading
     :END:
     where $|D|$ is the number of nodes in diagram $D$. The problem is NP-hard (because the min single BDD is NP-hard).
*** Research context
   - Vast literature on minimizing single BDD.
   - One of the central ideas: ``Dynamic variable reordering'' / *Sifting* algorithm (we will use it as a baseline).
   - Limited consideration of the multi-BDD version, and all working with BDDs (obviously).
**** The purpose of this work                                       :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     Try to avoid manipulations with BDD as much as possible, by introducing a
     ``simpler'' auxiliary problem.
** The simplified problem
*** How the BDDs are transformed?
*** The simplified problem
*** Plan of attack with the simplified problem
*** How to solve it now? Key properties
*** Branch...
*** ... and bound.
** Numerical experiments
*** Numerical experiments: strategy
    - First: consider the simplified problem in detail.
    - Then: solve the original problem, benchmark vs the baseline and consider scaling.
    - Analyze the solutions: original vs. simplified, problem structure.

*** Simplified problem: optima

**** Left                                                    :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.5
     :END:
     \centering
     \includegraphics[width=\textwidth]{./img/no_opts.eps}
**** Right                                                   :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.5
     :END:
     \centering
     \includegraphics[width=\textwidth]{./img/opts_diam.eps}
*** Simplified problem: heuristics
     \centering
     \includegraphics[width=\textwidth]{./img/simpl_heuristics.eps}
*** Objectives relative to the ``greedy sifts''
     \centering
     \includegraphics[width=\textwidth]{./img/orig_obj_histograms.eps}
*** Scaling with the problem size
     \centering
     \includegraphics[width=\textwidth]{./img/orig_runtimes.eps}

*** Simplified vs. Original problem solutions
     \centering
     \includegraphics[width=\textwidth]{./img/heuristic_simscore.eps}
*** Effects of the problem structure
     \centering
     \includegraphics[width=\textwidth]{./img/heuristic_simscore_vs_AB_simscore.eps}
* A BDD-based approach to a Facility Location Problem
  :PROPERTIES:
  :ALT_TITLE: BDDs for t-UFLP
  :END:
  :LOGBOOK:
  CLOCK: [2021-10-30 Sat 16:39]--[2021-10-30 Sat 20:05] =>  3:26
  CLOCK: [2021-10-30 Sat 16:01]--[2021-10-30 Sat 16:24] =>  0:23
  CLOCK: [2021-10-30 Sat 14:17]--[2021-10-30 Sat 14:37] =>  0:20
  :END:
** Section outline
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
#+LATEX: \tableofcontents[currentsection]
** Problem description
*** A variant of the Facility Location Problem                      :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
**** Descr                                                   :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.5
     :END:
     #+begin_export latex
\includegraphics[width=\textwidth]{img/cover-graph.eps}
     #+end_export

**** Eqns                                                    :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.5
     :END:
     - *Locate* facilities in a cheapest way, ...
     - ... to *cover* all points, ...
     - ... respecting the *budget* constraints, by facility ``type''.
** BDD representation
*** Problem formulation
**** Eqn                                                              :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.7
     :END:
     #+begin_export latex
\begin{flalign*}
  \min & \sum_{i=1}^M f_i x_i&&\\
    \textrm{s.t. } & \sum_{j\in S_i}x_j  \geq 1 & i=1,\ldots,M, &\onslide<2->{\alert{\rightarrow  \textrm{ ``Cover'' BDD}}}\\
    &\sum_{j\in T_t}x_j  \leq k_t & t=1,\ldots, K,&\onslide<2->{\alert{\rightarrow \textrm{ ``Type'' BDD}}}\\
    & x_i\in\{0,1\} &i=1,\ldots,M. &
\end{flalign*}
     #+end_export
**** Desc                                                             :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.3
     :END:
     Here:
     - $S_j$ -- adjacency lists,
     - $k_t$ -- budgets,
     - $f_i$ -- location costs,
     - $x_i$ -- location decisions.
*** How to build the cover BDD                                      :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :BEAMER_opt: t
    :END:
**** t-UFLP structure                                        :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.3
     :BEAMER_opt: t
     :END:
     \centering
     Original graph:\vspace{2ex}

     \includegraphics[width=\textwidth]{img/cover-graph.eps}
**** BDD example                                             :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.7
     :BEAMER_opt: t
     :END:
     \centering
     Cover BDD:\vspace{2ex}

     #+LATEX: \includegraphics[width=\textwidth]{img/cover-DD.eps}

**** Note                                                   :B_ignoreheading:
     :PROPERTIES:
     :BEAMER_env: ignoreheading
     :END:
     \vspace{2ex}
     \textbf{Building the diagram:}
     - Pick next point with the least ``uncertainty'': # of neighbors to be added to the BDD,
     - Process its adjacency list,
     - Repeat.
*** How to build the type BDD                                       :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :BEAMER_opt: t
    :END:
**** BDD example                                             :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.5
     :BEAMER_opt: t
     :END:
     \centering
     Part of Type BDD:\vspace{2ex}

     #+LATEX: \includegraphics[height=0.7\textheight]{img/type_DD.eps}
**** t-UFLP structure                                        :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.5
     :BEAMER_opt: t
     :END:
     - Consider: $\sum_{j\in T}x_j \leq k$ for $T=\{1,3,5,7,9,11\}$ and $k=2$.
     - Stack such blocks vertically.
     - Minimize the number of inversions with the Cover BDD by choosing the
       order of variables within each block.
     - Randomize the order of blocks.
*** Consistent Path Problem for t-UFLP  :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
    #+begin_export latex
\begin{subequations}
\scriptsize
  \begin{align*}
    \min & \sum \tikzmarkin<2>{obj}f_i v^{\cov}_{i,\hi{i}}\tikzmarkend{obj},\\
    \textrm{s.t. } & \tikzmarkin<3>{a}(3.5,-0.5)(-0.1,0.35)\sum_{i:\hi{i}=u\textrm{ or }\lo{i}=u}v^{\cov}_{iu} = \sum_{j:\hi{u}=j\textrm{ or } \lo{u}=j}v^{\cov}_{uj} \textrm{ for all } u\in L_2^{\cov}\cup\ldots\cup L_{(M-1)}^{\cov},\\
         & \sum_{j:\hi{\ROOT}=j\textrm{ or } \lo{\ROOT}=j}v^{\cov}_{\ROOT{}j} = 1,\\
         & \sum_{j:\hi{j}=u\textrm{ or } \lo{j}=u}v^{\cov}_{ju} = 1 \textrm{ for } u\in \{\T^{\cov},\F^{\cov}\},\tikzmarkend{a}\\
         & \tikzmarkin<4>{b}(3.5,-0.5)(-0.1,0.35)\sum_{i:\hi{i}=u\textrm{ or }\lo{i}=u}v^{\type}_{iu} = \sum_{j:\hi{u}=j\textrm{ or } \lo{u}=j}v^{\type}_{uj} \textrm{ for all } u\in L_2^{\type}\cup\ldots\cup L_{(M-1)}^{\type},\\
         & \sum_{j:\hi{\ROOT}=j\textrm{ or } \lo{\ROOT}=j}v^{\type}_{\ROOT{}j} = 1,\\
         & \sum_{j:\hi{j}=u\textrm{ or } \lo{j}=u}v^{\type}_{ju} = 1 \textrm{ for } u\in \{\T^{\type},\F^{\type}\},\tikzmarkend{b}\\
         &\tikzmarkin<5>{c}(0.1,-0.5)(-0.1,0.3) \sum_{j\in L^{\cov}_q} v^{\cov}_{j\hi{j}} = x_q \textrm{ for all } q=1,\ldots,M,\\
         & \sum_{j\in L^{\type}_q} v^{\type}_{j\hi{j}} = x_q \textrm{ for all } q=1,\ldots,M,\tikzmarkend{c}\\
         & v_{pq}\geq 0 \textrm{ for all valid } p,~q;\quad x_i\in\{0,1\}.
  \end{align*}
\end{subequations}
    #+end_export

** Solving the CPP
*** Approaches to solve the problem
    - Simple MIP (with $x_i\in\{0,1\}$ as decision variables),
    - CPP + MIP (with continuous BDD flows + $x_i$ as variables),
    - CPP $\rightarrow$ Align-BDD $\rightarrow$ shortest-path (no binary variables!)
** Numerical experiments
*** Comparing runtimes (random instances)
    \includegraphics[width=\textwidth]{./img/tUFLP_runtimes_overview.eps}
*** Runtimes breakdown
    \includegraphics[width=\textwidth]{./img/tUFLP_runtimes_breakdown.eps}
*** Alignment heuristic performance vs. problem structure
    \includegraphics[width=\textwidth]{./img/various_simpl_vs_min.eps}
** t-UFLP summary
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
*** Summary on t-UFLP
    - present an illustration for the Align-BDD heuristic (simplified problem),
    - introduce a problem, propose a CPP reformulation,
    - apply the heuristic to align the diagrams and obtain an LP,
    - demonstrate the runtimes in numerical experiments,
    - highlight the limits / effects of the problem structure.

* Monte Carlo Tree Search for DSPI
  :LOGBOOK:
  CLOCK: [2021-10-30 Sat 13:34]--[2021-10-30 Sat 13:35] =>  0:01
  :END:
** Section outline
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
#+LATEX: \tableofcontents[currentsection]
** Problem formulation
*** A game of ``interdiction'': intro                               :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
**** Pic: attacker and user
    :PROPERTIES:
    :BEAMER_col: 0.4
    :BEAMER_opt: [t]
    :END:

    #+ATTR_LATEX: width=\textwidth
    [[./img/SPI.png]]

**** Description
    :PROPERTIES:
    :BEAMER_col: 0.6
    :BEAMER_opt: [t]
    :END:
    - *Network:* a directed graph with two special nodes (source \textcircled{s} and terminal \textcircled{t}), and a pair of "costs" associated to each edge.
    - *User:* seeks to run through the graph, \textcircled{s} to \textcircled{t}, at min cost.
    - *Attacker:* maximizes the User's cost by "attacking" the arcs, having a limited "budget".

   We consider a *dynamic* version of the game, following cite:sefair2016. (NP-hard)

*** A game of ``interdiction'': formulation                         :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
    The Interdictor's optimal objective $z^*$ can be expressed as:
   #+begin_export latex
 \begin{equation*}
 z^*(S,i) = \max_{S^\prime \subseteq \FS{i}\setminus S~:~|S\cup S^\prime|\leq b} \Big\{\min_{j\in\FS{i}} \{z^*(S\cup S^\prime, j) + \widetilde{c}_{ij}(S\cup S^\prime)\}\Big\},
 \end{equation*}
   #+end_export
   where:
   - $S$: interdiction set,
   - $i$: current Evader's node, $\FS{i}$ -- forward star of node $i$,
   - $\widetilde{c}_{ij}$: arc traversal costs (given the interdiction),
   - $b$: Interdictor's budget.
   \pause

**** Existing algorithms (by Sefair & Smith)                        :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     - polynomial DP algorithm for a DAG
     - exact DP algorithm, exp time for general case.
** What do we propose?
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
*** Monte Carlo Tree Search
    - Maintain the game tree,
    - Try not to create all the nodes,
    - Prune the definitely suboptimal ones,
    - Drive the tree growth by a computationally cheap objective estimate (e.g.,
      based on simulated games).

** MCTS framework
*** The ``game tree''
 Create a ``game tree'', where *nodes* contain the following information.
 - Current *status*
   - $\pos{j}\in \mathcal{N}$: where is the Evader,
   - $S_j\subseteq \mathcal{A}$: what is interdicted,
   - $\tau(j)$: who's turn is it (Interdictor/Evader)\pause
 - Possible further *development*
   - $\children{j}$: child game tree nodes,
   - $\actions{j}$: available actions.\pause
 - *Costs* info, to drive the search and prune the tree
   - $\widehat{Q}_j$: cost-to-go (starting from this node),
   - $\LB{j},~\UB{j}$: bounds on the true cost-to-go,
   - $N_j\in\mathbb{N}$: how many times the node was visited\pause

  So, we iterate through *episodes*, each one implying a ``full cycle'' of the game tree update in four *phases*.
    
*** Summary figure setup (technical)                                 :ignore:
   #+begin_export latex
 \tikzstyle{sel} = [minimum size=2mm, NavyBlue]
 \tikzstyle{stdnode} = [draw, fill, circle, lightgray, minimum size=2mm]
 \tikzstyle{empty} = [draw=none, fill=none]
 \tikzstyle{rootnode} = [fill=none]
 \tikzstyle{edge from parent} = [draw=lightgray]
   #+end_export

*** Phase 1. Selection                                        
  #+begin_export latex
\begin{minipage}{0.3\textwidth}
% selection
\begin{tikzpicture}[%level distance=5mm,
level 1/.style={level distance=10mm,sibling distance=12mm},
level 2/.style={level distance=10mm,sibling distance=7mm},
level 3/.style={level distance=10mm,sibling distance=7mm},
font=\scriptsize,inner sep=2pt,every node/.style=stdnode]

\node[NavyBlue, sel] {} % root
child {node {}
        child {node {}} 
        child {node {} 
            child {node{}} 
            child {node{}}
        }
    edge from parent }
child {node {}}
child   {[NavyBlue] node[sel] {}
            child {[black] node {}}
            child {node[sel] {}
                   edge from parent[NavyBlue]
            }
        edge from parent[NavyBlue]
        };
\end{tikzpicture}
\end{minipage}\hfill
\begin{minipage}{0.5\textwidth}
\textbf{What's happening:}
\begin{itemize}
  \item Start at the root node,
  \item Use \textit{tree policy} to choose the next node recursively...
  \item ... pruning nodes as we go, when possible ...
  \item ... until we reach a leaf.
\end{itemize}
\psep{}

\textbf{What's updated:}
\begin{itemize}
  \item Nothing in the tree.
  \item Along the way: bounds for pruning (more momentarily!) + path costs.
\end{itemize}
\end{minipage}
  #+end_export
*** Phase 2. Expansion                                        
  #+begin_export latex
% expansion
\begin{minipage}{0.3\textwidth}
\begin{tikzpicture}[%level distance=5mm,
level 1/.style={level distance=10mm,sibling distance=12mm},
level 2/.style={level distance=10mm,sibling distance=7mm},
level 3/.style={level distance=10mm,sibling distance=7mm},
font=\scriptsize,inner sep=2pt,every node/.style=stdnode]

\node[rootnode] {} % root
child {node {}
        child {node {}} 
        child {node {} 
            child {node{}} 
            child {node{}}
        }
    edge from parent }
child {node {}}
child   {node {}
            child {node {}}
            child {node {}
                child {[NavyBlue] node[sel]{} edge from parent[NavyBlue]}
                child {[NavyBlue] node[sel]{} edge from parent[NavyBlue]}
                child {[NavyBlue] node[sel]{} edge from parent[NavyBlue]}
            }
        };
\end{tikzpicture}
\end{minipage}\hfill
\begin{minipage}{0.5\textwidth}
\textbf{What's happening:}
\begin{itemize}
  \item Create child nodes for possible actions.
\end{itemize}
\psep{}

\textbf{What's updated:}
\begin{itemize}
  \item New nodes are created,
  \item UBs and LBs are calculated
\end{itemize}\psep{}

\textbf{Note:} Some inconsistencies can be introduced here, between child and parent nodes.
\end{minipage}
  #+end_export
*** Phase 3. Roll-outs                                        
  #+begin_export latex
% roll-outs
\begin{minipage}{0.3\textwidth}
\begin{tikzpicture}[%level distance=5mm,
level 1/.style={level distance=10mm,sibling distance=12mm},
level 2/.style={level distance=10mm,sibling distance=7mm},
level 3/.style={level distance=10mm,sibling distance=7mm},
font=\scriptsize,inner sep=2pt,every node/.style=stdnode]

\node[rootnode] {} % root
child {node {}
        child {node {}} 
        child {node {} 
            child {node{}} 
            child {node{}}
        }
    edge from parent }
child {node {}}
child {node {}
       child {node {}}
       child {node {}
              child {node[sel] (a1) {}
                     child {node[empty, NavyBlue] (b1) {...} edge from parent[draw=none]
                       child{node[sel, fill=none] (c1) {}
                             edge from parent[draw=none]}}}
                child {node[sel] (a2) {}
                    child {node[empty, NavyBlue] (b2) {...} edge from parent[draw=none]
                       child{node[sel, fill=none] (c2) {}
                             edge from parent[draw=none]}}}
                child {node[sel] (a3) {}
                    child {node[empty, NavyBlue] (b3) {...} edge from parent[draw=none]
                       child{node[sel, fill=none] (c3) {}
                             edge from parent[draw=none]}}}}
                             };
\draw[bend left, NavyBlue, shorten <=2pt] (a1) to (b1);
\draw[->, bend right, NavyBlue, shorten >= 2pt] (b1) to (c1);
\draw[bend right, NavyBlue, shorten <=2pt] (a2) to (b2);
\draw[->, bend left, NavyBlue, shorten >=2pt] (b2) to (c2);
\draw[bend left, NavyBlue, shorten <=2pt] (a3) to (b3);
\draw[->, bend right, NavyBlue, shorten >=2pt] (b3) to (c3);
\draw[dashed, NavyBlue, rounded corners=7] ($(c1)+(-.3,.3)$)rectangle($(c3)+(.3,-.3)$);
\node[draw=none, fill=none, yshift=-4.5mm, NavyBlue] at ($(c1)!.5!(c3)$){Terminal nodes}; 
\end{tikzpicture}%
\vspace{-2.5em}
\end{minipage}\hfill
\begin{minipage}{0.5\textwidth}
\textbf{What's happening:}
\begin{itemize}
  \item Run a random simulated game from each node,
  \item Calculate cost-to-go estimate $\widehat{Q}_j$ as the simulated game cost.
\end{itemize} \psep{}

\textbf{What's updated}
\begin{itemize}
  \item Cost-to-go for each new node.
\end{itemize}\psep{}

\textbf{Note:} We do not record the intermediate game states occured during roll-outs!
\end{minipage}
  #+end_export

*** Phase 4. Backpropagation                                  
  #+begin_export latex
% backpropagation
\begin{minipage}{0.3\textwidth}
\begin{tikzpicture}[%level distance=5mm,
level 1/.style={level distance=10mm,sibling distance=12mm},
level 2/.style={level distance=10mm,sibling distance=7mm},
level 3/.style={level distance=10mm,sibling distance=7mm},
font=\scriptsize,inner sep=2pt,every node/.style=stdnode]

\node[sel] (d) {} % root
child {node {}
        child {node {}} 
        child {node {} 
            child {node{}} 
            child {node{}}
        }
    edge from parent }
child {node {}}
child {node[sel] (c) {}
            child {node {}}
            child {node[sel] (b) {}
                child {node{}}
                child {node{}}
                child {node[sel] (a) {}}
            }
        };

\draw[->, NavyBlue, bend right, shorten >=2pt, shorten <=2pt] (a) to (b.east);
\draw[->, NavyBlue, bend right, shorten >=2pt, shorten <=2pt] (b.north east) to (c.east);
\draw[->, NavyBlue, bend right, shorten >=2pt, shorten <=2pt] (c.north east) to (d.east);
\end{tikzpicture}
\end{minipage}\hfill
\begin{minipage}{0.5\textwidth}
\textbf{What's happening:}
\begin{itemize}
  \item Start at the selected node,
  \item Recursively update (``propagate'') node information for parents ...
  \item ... until we reach the root.
\end{itemize} \psep{}

\textbf{What's updated:}
Information in each parent node, using the child nodes:
\begin{itemize}
  \item UBs and LBs
  \item Cost-to-go estimate: the best value (given the turn).
\end{itemize}
\end{minipage}
  #+end_export

*** The Algorithm                                                   :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
The algorithm can perform actions for both players. Each turn involves two
steps:\vspace{2ex}

**** THINK ...                                               :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.4
     :BEAMER_opt: t
     :END:
   \textbf{Step 1.} THINK.\vspace{1ex}

   We iteratively improve the tree (while we have budget):\vspace{1ex}

    \textbf{FOR} $k=1,\ldots, K$ \textbf{DO}
    - Selection
    - Expansion
    - Roll-outs
    - Backpropagation
    \textbf{END.}

**** ACT                                                     :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.4
     :BEAMER_opt: t
     :END:
     \textbf{Step 2.} ACT.\vspace{1ex}

     ... then pick an action corresponding to the ``most
     attractive'' child node of the root.

*** There are several secret ingredients
   #+begin_export latex
   \begin{figure}
   \includegraphics[width=\textwidth]{img/ingredient.jpg}
   \end{figure}
   #+end_export 
   
*** SI-1. How to select?
    - \textbf{with probability $\varepsilon$}: choose at random;
    - \textbf{otherwise}, a child node with the *best score*:
    #+begin_export latex
  \begin{equation*}
  R_j \defeq \underbrace{\sigma_i (\widetilde{C}_{ij} + \widehat{Q}_j)}_{\textrm{best cost-to-go}} ~~+ ~~\underbrace{C_p\sqrt{\log(N_i) / N_j}}_{\textrm{encourage exploration}}, \quad \textrm{ for all } j\in\children{i}
  \end{equation*}
    #+end_export

    ``Best'' here depends on the turn (the Evader will choose the smallest cost estimate, the Interdictor --- the largest).
*** SI-2. How to prune?
    We leverage the classic idea of *alpha--beta pruning*:
    \vspace{2ex}
**** Pic                                                     :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.4
     :END:
     #+begin_export latex
 \begin{tikzpicture}[%level distance=5mm,
 level 1/.style={level distance=10mm,sibling distance=12mm},
 level 2/.style={level distance=10mm,sibling distance=7mm},
 level 3/.style={level distance=10mm,sibling distance=7mm},
 font=\scriptsize,inner sep=2pt,
 edge from parent/.style={draw=black},
 every node/.style={draw, circle}]

 \node[label=above:{root}]{I} % root
 child {node[label=left:{$(A)$}] {E}
         child {node[label=below:{$j^{\prime\prime}$}] {I}} 
         child {node[sel, label=below:{$j^\prime$}] {I}} 
         child {node {I}} 
     edge from parent node[draw=none, left] {pass}}
 child {node {I}}
 child   {node[sel, label=right:{$(B)$}] {I}
             child {node {I}
                 child {node[draw=none] {...}}
                 child {node[draw=none] {...}}}
             child {node {I}
                 child {node[draw=none] {...}}}
         edge from parent};
 \end{tikzpicture}
     #+end_export
**** Description                                             :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.6
     :END:
 Maintain two running numbers (bounds):
 - $\alpha$: the worst (minimum) alternative cost achievable by the Interdictor,
 - $\beta$: the worst (maximum) alternative cost achievable by the Evader.
\vspace{2ex}
 *Pruning condition:* $\beta \leq \ahat_j$ or $\bhat_j \leq \alpha$, where
- $\ahat_j =\pi_n+\LB{j}$  (Interdictor's turns), and
- $\bhat_j = \pi_n+\widetilde{C}_{nj} + \UB{j}$ (Evader's turns)
*** SI-3. How to back-propagate?
  Assuming the Evader's turn, and $i$ being the current game tree node:
  - Update the bounds:
 #+begin_export latex
 \begin{align*}
   \UB{i} &\gets \min_{j\in\children{i}} \Big\{ \widetilde{C}_{ij}(S_i) + \UB{j} \Big\},\\
   \LB{i} &\gets \min_{j\in\children{i}} \Big\{ \widetilde{C}_{ij}(S_i) + \LB{j} \Big\}.
 \end{align*}
 #+end_export
 
 - Update the cost-to-go estimate:
 #+begin_export latex
 \begin{equation*}
 \widehat{Q}_i \gets \min_{j\in\children{i}} \Big\{ \widetilde{C}_{ij}(S_i) + \widehat{Q}_j\Big\}.
 \end{equation*}
 #+end_export
*** SI-4. Bounds
    Are inspired by Sefair & Smith 2016:
    - \textbf{Lower bound:} restrict the *Attacker*. Make attacks ``expire'' after a single turn).
    - \textbf{Upper bound:} restrict the *Interdictor*. Remove some arcs so that $G$ is a DAG ($\Rightarrow$ DSPI is simple to solve.) Repeat multiple times and choose the best bound.
** Numerical experiments
*** Numerical experiments: strategy
   - How does it perform on pre-defined instances? (relative to the known optimum, and to the bounds)
   - How does it perform on randomly generated instances with different budgets?
   - What's the dynamics of the tree construction? How does the algorithm work?
   - What's the point of ``playing out'', i.e., changing root nodes?

*** Pre-defined instances
    #+begin_export latex
    \begin{figure}
    \includegraphics[width=\textwidth]{img/fig_known.png}
    \end{figure}
    #+end_export
*** Random instances (snapshot)
    #+begin_export latex
 \begin{figure}
 \includegraphics[width=\textwidth]{img/fig_bounds.png}\vspace{0.5ex}
 \includegraphics[width=\textwidth]{img/fig_runtimes.png}
 \end{figure}
    #+end_export
*** Convergence profiles                                            :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
    #+begin_export latex
    \begin{minipage}{0.45\textwidth}
    {\scriptsize \centering $\varepsilon=0.05$\vspace{1ex} \\}
    \includegraphics[width=0.4\paperwidth]{img/conv_profile_2eps_0.05.png}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
    {\scriptsize \centering $\varepsilon=0.5$\vspace{1ex} \\}
    \includegraphics[width=0.4\paperwidth]{img/conv_profile_2eps_0.5.png}%
    \end{minipage}
    #+end_export
*** A remark: that's not just different runs                        :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
**** Pic                                                     :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.6
     :END:
    #+begin_export latex
    \includegraphics[height=0.8\textheight]{img/treesizes.png}
    #+end_export
**** Notes                                                   :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.4
     :END:
     For each value of $\varepsilon$ (0.05, 0.5, and 1) we performed three runs, to confirm these are indeed different ``modes'' of the algorithm.

*** Play-out vs. first-move strategy
    #+begin_export latex
    \includegraphics[width=\textwidth]{img/courage.eps}
    #+end_export
** On correctness
*** Why does it work? (A sketch on ``correctness'')
**** Proposition                                                  :B_theorem:
     :PROPERTIES:
     :BEAMER_env: theorem
     :END:
  $$\lim_{k\rightarrow \infty} \mathbb{P}\{Q^k_{\rnode{}} = \textrm{true optimum}\}=1$$
**** Proof sketch                                           :B_ignoreheading:
     :PROPERTIES:
     :BEAMER_env: ignoreheading
     :END:
    A sketch of the proof:

    - The game tree has finite number of nodes (there is a bound independent from $K$).
    - We never cut off all the optima $\Rightarrow$ the tree contains at least one.
    - What is left is a finite-size minimax tree, containing an optimum.
    - As $K\rightarrow\infty$, probability to select every node for expansion converges to 1.

*** Why in the world the tree is finite?
**** Initial graph G                                         :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.15
     :END:
     Network:
     #+begin_export latex
    \centering
    \begin{tikzpicture}[%level distance=5mm,
      level 1/.style={level distance=10mm,sibling distance=12mm},
      level 2/.style={level distance=10mm,sibling distance=7mm},
      level 3/.style={level distance=10mm,sibling distance=7mm},
      font=\scriptsize,inner sep=2pt,
      every node/.style={draw=black, circle}]
      \node[draw=none] {...}
      child {node (a) {1}
        child {node (b) {2}
          child {node (c) {3}
            child {node[draw=none] {...}}
            child {node[draw=none] {...}}
            edge from parent node[left, draw=none] {$c_{23}$}}
          edge from parent node[left, draw=none] {$c_{12}$}}};
      \draw[->, bend right, shorten >=2pt, shorten <=2pt] (b.east) to (a.east);
      \node[draw=none, fill=none, xshift=7mm] at ($(a)!.5!(b)$){$c_{21}$}; 
    \end{tikzpicture}\pause
 #+end_export
**** Tree-1                                                  :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.30
     :END:
     After the *first* expansion:
     \vspace{2ex}

 #+begin_export latex
    \centering
    \begin{tikzpicture}[%level distance=5mm,
      level 1/.style={level distance=10mm,sibling distance=12mm},
      level 2/.style={level distance=10mm,sibling distance=7mm},
      level 3/.style={level distance=10mm,sibling distance=15mm},
      font=\scriptsize,inner sep=5pt,
      every node/.style={draw=black}]
      \node[draw=none] {...}
      child {node {$p=1$}
        child {node (A) {$p=2$}
          child {node (B) {$p=1$}}
          child {node (C) {$p=3$}}}};
      \node[draw=none, xshift=-3mm] at (A.west) {$(A)$};
      \node[draw=none, xshift=-3mm] at (B.west) {$(B)$};
      \node[draw=none, xshift=3mm] at (C.east) {$(C)$};
    \end{tikzpicture}
#+end_export
\pause
**** Tree-2                                                  :B_column:BMCOL:
     :PROPERTIES:
     :BEAMER_env: column
     :BEAMER_col: 0.5
     :END:
     After the *second* expansion:
     \vspace{2ex}

#+begin_export latex
   \centering
   \begin{tikzpicture}[%level distance=5mm,
     level/.style={level distance=10mm,sibling distance=20mm},
     level 3/.style={sibling distance=30mm},
     font=\scriptsize,inner sep=5pt,
     every node/.style={draw=black}]
     \node[draw=none] {...}
     child {node {$p=1$}
       child {node (nA) {$p=2$}
         child {node[blue] (tn1) {$p=1$}
           child {node[blue] {$p=2$}
             child {node[blue] {$p=1$}
               child {node[draw=none] {...}}
               edge from parent[blue]}
             child {node[blue] (D) {$p=3$}
               child {node[draw=none] {...}}
               child {node[draw=none] {...}}
               edge from parent[blue]}
               edge from parent[blue]}
               edge from parent[blue]}
         child {node (nexit) {$p=3$}
           child {node[draw=none] {...}}
           child {node[draw=none] {...}}}}};
     \node[draw=none, xshift=3.5mm] at (nexit.east) {$(C)$};
     \node[draw=none, xshift=3.5mm] at (D.east) {$(D)$};
     \node[draw=none, xshift=-3mm] at (nA.west) {$(A)$};
     \node[draw=none, xshift=-3.5mm] at (tn1.west) {$(B)$};
   \end{tikzpicture}
    #+end_export
* TODO Conclusion
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
** Summary
** Future research

* Technical :ignore:
*** Mentioned sources                                               :B_frame:
    :PROPERTIES:
    :BEAMER_env: frame
    :END:
    \scriptsize
   bibliographystyle:unsrtnat
   [[bibliography:/home/bochkarev/Dropbox/bibliography/references.bib]]

* Org  :noexport:
** TODO Formatting brush-up
** TODO Dry run

